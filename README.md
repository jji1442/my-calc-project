# my-calc-project

## 목차
[기획 의도](#1.기획의도)
2. [시제품 개발 전 시행착오](#2.-시제품-개발-전-시행착오)

## 1. 기획의도
  
- 환산주스탯(=효율분석 사이트)의 특징<br>
  1.&nbsp;보편적 가이드라인.<br>
  &emsp;- 상위권 유저의 전투 데이터를 기반으로 제작한 헥사 코어 강화 순서를 제공하여 초보자에게 보편적 가이드라인을 제시합니다.<br>
  2.&nbsp;사용자의 강화 효율과 불일치.<br>
  &emsp;- 사용자의 전투 방식이 제공된 가이드라인과 다른 경우, 실제 강화 효율에 큰 차이가 발생할 수 있습니다.<br>
  3.&nbsp;개인별 최적화의 부재.<br>
  &emsp;- 개인별 '스킬 쿨타임 감소'나 '특수 반지 스킬' 같은 변수를 반영하지 못합니다.<br>
  4.&nbsp;고정된 강화 순서 제공.<br>
  &emsp;- 헥사 코어 레벨에 따라 달라지는 강화 효율을 고려하지 않고 고정된 강화 순서 및 강화 효율만을 제공합니다.

- 개인별 분석 도구의 특징<br>
  1.&nbsp;개인별 최적화.<br>
  &emsp;- 이 도구는 사용자에게 데이터를 직접 받아 가장 효율적인 강화 순서를 제공합니다.

<br><br><br>

## 2. 시제품 개발 전 시행착오



<br><br><br>

## 3. 개발 방향성
### 구조 1
- 설명
  - 강화 효율 측정에 필요한 모든 데이터(현재 레벨 기준 스킬 %데미지, 다음 레벨 기준 스킬 %데미지, 스킬 1회당 공격횟수, 측정된 공격횟수 등)를 입력받아 다음 스킬 강화를 추천하는 구조.
- 이점<br>
  1.&nbsp;외부 요인에 영향받지 않는 분석 가능.<br>
  &emsp;- 밸런스 패치와 관계없이 효율 계산이 가능합니다.
- 문제점<br>
  1.&nbsp;많은 수동 입력.<br>
  &emsp;- 모든 스킬 정보를 직접 입력해야 하는 높은 입력 난이도가 존재합니다.<br>
  &emsp;- 특히 스킬별 1회당 공격횟수 같은 세부 정보를 모두 기억하기 어려워 잘못된 정보 기입 시 잘못된 효율이 측정되는 경우가 발생합니다.

### 구조 2
- 설명
  - 스킬 정보는 데이터베이스에 저장되어 있으며, 사용자에게 필수 데이터(코어별 레벨, 해당 스킬 점유율, 재화 시세)만을 입력받아 다음 스킬 강화를 추천하는 구조.
- 이점<br>
  1.&nbsp;낮은 수동 입력.<br>
  &emsp;- 모든 스킬 정보를 직접 입력해야 하는 기존과는 달리, 사용자에게 필수적인 데이터만을 요구합니다.
- 문제점<br>
  1.&nbsp;개발자의 관리 부담이 많음.<br>
  &emsp;- 밸런스 패치 마다 모든 스킬의 수치를 일일이 수정해야 하는 번거로움이 있습니다.<br>
  2.&nbsp;데이터의 부정확성.<br>
  &emsp;- 개발자가 업데이트를 늦추거나 누락하면, 사용자들은 구 버전의 데이터를 기반으로 잘못된 효율을 계산하게 됩니다.
- 구조를 변경하게된 이유
  - 많은 수동 입력은 다수의 사용자들의 진입장벽이 될 것이기 때문에, 이를 개선하고자 데이터베이스에 스킬 정보를 저장하는 구조로 변경하였습니다.

### 구조 3-1
- 설명
  - 넥슨에서 제공하는 API(이하 넥슨 API)를 활용하여, 사용자에게 필수 데이터(코어별 레벨, 해당 스킬 점유율, 재화 시세)만을 입력받아 다음 스킬 강화를 추천하는 구조.
- 이점<br>
  1.&nbsp;낮은 수동 입력.<br>
  &emsp;- 모든 스킬 정보를 직접 입력해야 하는 기존과는 달리, 사용자에게 필수적인 정보만을 요구합니다.<br>
  2.&nbsp;개발자의 관리 부담이 적어짐.<br>
  &emsp;- 넥슨 API에 모든 스킬 정보가 기재되어 있어, 개발자가 일일이 업데이트해야 하는 관리 부담이 줄어듭니다.<br>
  3.&nbsp;데이터의 신뢰성 확보.<br>
  &emsp;- 넥슨 API를 활용함으로써, 데이터의 신뢰성을 확보하고 분석 결과의 정확성을 높였습니다.<br>
  4.&nbsp;데이터베이스 관리 비용 절감.<br>
  &emsp;- 게임 데이터를 직접 관리하는 대신 넥슨 API를 활용함으로써, 데이터베이스에 직업별 스킬 정보를 저장할 필요가 없어 데이터베이스 관리 비용을 절감했습니다.
- 문제점<br>
  1.&nbsp;배포 및 접근성의 한계.<br>
  &emsp;- 현재 구상 중인 사용방식은 파이썬 응용 프로그램에 넥슨 API를 사용하는 방식입니다.<br>
  &emsp;- 사용자는 파이썬 실행 파일을 직접 설치해야 하고, 응용 프로그램 업데이트 시마다 매번 다운로드해야 하는 번거로움이 있어 접근성이 낮다는 한계가 있습니다.
- 구조를 변경하게된 이유
  - '구조 2'를 통해 사용자의 입력 부담은 해결했지만, 밸런스 패치마다 모든 스킬 정보를 수동으로 업데이트해야하는 비효율적인 문제가 남아있었습니다. 이는 도구의 신뢰성을 떨어뜨릴 수 있다고 판단했습니다. 따라서 직접 데이터를 관리하는 대신, 넥슨 API를 통해 최신 정보를 효율적으로 수집하고 관리 부담을 해결하고자 이 구조를 구상했습니다.

### 구조 3-2
- 설명
  - 스킬 정보를 표기 및 수정하는 웹 사이트를 구축하여, 사용자에게 필수 데이터(코어별 레벨, 해당 스킬 점유율, 재화 시세)만을 입력받아 다음 스킬 강화를 추천하는 구조.
- 이점<br>
  1.&nbsp;낮은 수동 입력.<br>
  &emsp;- 모든 스킬 정보를 직접 입력해야 하는 기존과는 달리, 사용자에게 필수적인 정보만을 요구합니다.<br><br>
  2.&nbsp;배포 및 접근성이 용이함.<br>
  &emsp;- 웹 사이트로 제공되는 방식은 사용자가 직접 다운로드하고 설치해야 하는 방식에 비해 접근성이 높습니다.<br>
  3.&nbsp;높은 가시성.<br>
  &emsp;- 글로 제작된 파이썬 응용프로그램에 비해 웹 사이트에 이미지(스킬 이미지, 강화 효율표)를 넣어 가시성을 높힐 수 있습니다.<br>
  4.&nbsp;스킬 정보 변경 가능.<br>
  &emsp;- 밸런스 패치 때 수치적 변경만 있다면, 사용자가 직접 변경하여 효율을 측정할 수 있습니다.
- 문제점<br>
  1.&nbsp;개발자의 관리 부담이 많음.<br>
  &emsp;- 밸런스 패치마다 모든 스킬의 수치를 일일이 수정해야 하는 번거로움이 있습니다.<br>
  2.&nbsp;데이터의 부정확성.<br>
  &emsp;- 개발자가 업데이트를 늦추거나 누락하면, 사용자들은 구 버전의 데이터를 기반으로 잘못된 효율을 계산하게 됩니다.<br>
  3.&nbsp;데이터베이스 관리 비용 상승.<br>
  &emsp;- 모든 스킬 정보를 저장해야하므로 데이터베이스 관리 비용이 상승합니다.
- 구조를 변경하게된 이유
  - 넥슨 API에서 모든 스킬 정보를 주는지 명확하지 않아, 웹사이트를 제작하여 사용자가 스킬 정보를 수정할 수 있는 구조를 구상해보았습니다.

<br><br><br>

## 4. 시제품 제작
### 제작 기한
  - 예상 기간: 영업일 기준 8.5일.<br>
    (5일 + 4 * 8일 + 14일) / 6 = 8.5일.
  - 시작일: 25.08.14.
  - 기한일: 25.08.26.
  - 완성일: 25.09.04.(영업일 기준 15일)

### 기능 요구사항
- 전제조건<br>
  1.&nbsp;강화 효율 측정은 25.08.14 개발자의 아크를 기준으로 작성함.<br>
  2.&nbsp;기본 스킬의 %데미지는 '쓸만한 컴뱃 오더스'가 사용 중인 상태를 기준으로 작성함.<br>
  3.&nbsp;'어비스 차지드라이브 스펠VI'는 스킬 레벨에 따라 '대상에게 적중 시 보스 공격 시 데미지 증가'의 효과가 증가하지만, 시제품에선 스킬 %데미지만의 효율을 측정하기 때문에 제외하고 측정함.<br>
  4.&nbsp;분석의 범위를 명확히 설정하기 위해서 '다가오는 죽음'은 '인피니티 스펠' 사용 시에만 발생하는 경우를 기준으로 강화 효율을 측정함.<br>
  5.&nbsp;마스터리 코어 효율 계산에 영향을 미치는 '강화 코어의 인피니티 스펠 사용 시 다가오는 죽음 %p 상승'은 19레벨 기준으로 계산함.<br>
  
> &emsp;'쓸만한 컴뱃 오더스'를 사용 시 '일부 스킬만' 최대 레벨인 30레벨에서 31레벨로 상승하여 최대 레벨을 기준으로 스킬 %데미지를 저장함.<br>
> &emsp;'인피니트 스펠'은 50초간 '다가오는 죽음'이 3개 추가로 생성함. 이 스킬은 강화 코어의 효과를 받아 '다가오는 죽음'의 데미지를 133%p 추가로 상승시킴.

- 입력되는 데이터<br>
  1.&nbsp;마스터리 코어별 현재 레벨.<br>
  2.&nbsp;스킬별 점유율.

- 출력되어야할 데이터<br>
  1.&nbsp;스킬 종류.<br>
  2.&nbsp;스킬 추천 레벨.<br>
  3.&nbsp;최종데미지 상승율.<br>
  4.&nbsp;100억당 최종데미지 상승율.

### 구현 요구사항
- 데이터 구조
  - 외부 데이터(불변)
    - 기본 스킬(하이퍼/4차 이하)(딕셔너리)
      - 스킬 이름(딕셔너리)
        - 최대 레벨 기준 %데미지(변수)
    - 마스터리 코어1(딕셔너리)
      - 스킬 이름(딕셔너리)
        - 30레벨 기준 %데미지(변수)
        - 1레벨 상승 시 %데미지 상승량(%p)(변수)
    - 마스터리 코어2(딕셔너리)
      - 스킬 이름(딕셔너리)
        - 30레벨 기준 %데미지(변수)
        - 1레벨 상승 시 %데미지 상승량(%p)(변수)
    - 마스터리 코어3(딕셔너리)
      - 스킬 이름(딕셔너리)
        - 30레벨 기준 %데미지(변수)
        - 1레벨 상승 시 %데미지 상승량(%p)(변수)
    - 마스터리 코어4(딕셔너리)
      - 스킬 이름(딕셔너리)
        - 30레벨 기준 %데미지(변수)
        - 1레벨 상승 시 %데미지 상승량(%p)(변수)
    - 마스터리 코어 1~30레벨 재화 소모량(리스트)
    - 마스터리 코어 리스트 = [마스터리 코어1, 마스터리 코어2, 마스터리 코어3, 마스터리 코어4]

  - 내부 데이터(사용자 캐릭터 정보, 변동)
    - 마스터리 코어1(딕셔너리)
      - 현재 레벨(변수)
      - 데미지 상승율(딕셔너리)
        - 1레벨 상승 시 최종데미지 상승율(변수)
        - 1레벨 상승 시 100억당 최종데미지 상승율(변수)
        - 5레벨 상승 시 평균 최종데미지 상승율(변수)
        - 5레벨 상승 시 100억당 평균 최종데미지 증가율(변수)
      - 스킬(딕셔너리)
        - 스킬 이름(딕셔너리)
          - 현재 레벨 기준 %데미지(변수)
          - 1레벨 상승 시 %데미지 상승량(%p)(변수)
          - 점유율(변수)
    - 마스터리 코어2(딕셔너리)
      - 현재 레벨(변수)
      - 데미지 상승율(딕셔너리)
        - 1레벨 상승 시 최종데미지 상승율(변수)
        - 1레벨 상승 시 100억당 최종데미지 상승율(변수)
        - 5레벨 상승 시 평균 최종데미지 상승율(변수)
        - 5레벨 상승 시 100억당 평균 최종데미지 증가율(변수)
      - 스킬(딕셔너리)
        - 스킬 이름(딕셔너리)
          - 현재 레벨 기준 %데미지(변수)
          - 1레벨 상승 시 %데미지 상승량(%p)(변수)
          - 점유율(변수)
    - 마스터리 코어3(딕셔너리)
      - 현재 레벨(변수)
      - 데미지 상승율(딕셔너리)
        - 1레벨 상승 시 최종데미지 상승율(변수)
        - 1레벨 상승 시 100억당 최종데미지 상승율(변수)
        - 5레벨 상승 시 평균 최종데미지 상승율(변수)
        - 5레벨 상승 시 100억당 평균 최종데미지 증가율(변수)
      - 스킬(딕셔너리)
        - 스킬 이름(딕셔너리)
          - 현재 레벨 기준 %데미지(변수)
          - 1레벨 상승 시 %데미지 상승량(%p)(변수)
          - 점유율(변수)
    - 마스터리 코어4(딕셔너리)
      - 현재 레벨(변수)
      - 데미지 상승율(딕셔너리)
        - 1레벨 상승 시 최종데미지 상승율(변수)
        - 1레벨 상승 시 100억당 최종데미지 상승율(변수)
        - 5레벨 상승 시 평균 최종데미지 상승율(변수)
        - 5레벨 상승 시 100억당 평균 최종데미지 증가율(변수)
      - 스킬(딕셔너리)
        - 스킬 이름(딕셔너리)
          - 현재 레벨 기준 %데미지(변수)
          - 1레벨 상승 시 %데미지 상승량(%p)(변수)
          - 점유율(변수)
    - 마스터리 코어 리스트 = [마스터리 코어1, 마스터리 코어2, 마스터리 코어3, 마스터리 코어4]<br><br>
    
     >&emsp;주의 사항1: 기본 스킬의 스킬 이름의 하위 항목에 30레벨 기준 %데미지라고 작성하지 않은 이유는 '쓸만한 컴뱃 오더스'를 사용 시 '일부 스킬만' 최대 레벨인 30레벨에서 31레벨로 상승하기 때문에 최대 레벨이라고 작성함.<br>
     >&emsp;주의 사항2: 5레벨 상승 시 측정하는 이유는 특정 구간에서 효율이 급격하게 감소했다가 효율이 다시 올라가는 구조이기 때문에 구간별 소모 재화량(평균) 중 가장 좋은 효율을 기준으로 평균을 내어 작성함.

    스킬 레벨별 재화 소모량
    | 스킬 레벨 | 재화 소모량 |
    |:---:|:---:|
    | 8 -> 9 | 33 |
    | 9 -> 10 | 100 |
    | 10 -> 11 | 40 |
    | 11 -> 12 | 45 |
    | 12 -> 13 | 50 |
    | 13 -> 14 | 55 |
    | 14 -> 15 | 60 |

    구간별 재화 소모량(평균)
    | 스킬 레벨 | 재화 소모량 |
    |:---:|:---:|
    | 9 -> 13 | 총합 235 평균 58.75 |
    | 9 -> 14 | 총합 290 평균 58.00 |
    | 9 -> 15 | 총합 350 평균 58.33 |

- 메인 함수<br>
  1.&nbsp;사용자로부터 입력받는 함수 실행.<br>
  2.&nbsp;현재 레벨 기준 스킬 %데미지 조정하는 함수 실행.<br>
  3.&nbsp;강화효율 산출하는 함수 실행.<br>
  4.&nbsp;강화 추천하는 함수 실행.<br>
  5.&nbsp;결과 출력하는 함수 실행. + if not 리턴값: break<br>
  6.&nbsp;점유율 재조정하는 함수 실행.<br>
  7.&nbsp;데미지 업데이트하는 함수 실행.<br>
  8.&nbsp;위의 3~7를 반복.<br>

- 정의할 함수 종류
  - 사용자로부터 입력받는 함수.
    - 매개변수
      - 마스터리 코어 리스트(리스트)
    - 처리과정
      - 사용자로부터 마스터리 코어별 현재 레벨, 스킬별 점유율을 입력받음.
      - 입력받은 데이터가 정상적인 데이터인지 확인함.
      - 검증된 데이터를 마스터리 코어 리스트(리스트)에 저장함. 
    - 처리사항
      - 마스터리 코어별 현재 레벨이 int 형식이 아니라면, 다시 입력.
        - try: except Value Error:를 활용.
      - 마스터리 코어별 현재 레벨이 0이하 또는 31이상이라면, 다시 입력.
      - 스킬별 점유율이 int 형식 또는 float 형식이 아니라면, 다시 입력.
        - try: except Value Error:를 활용.
      - 스킬별 점유율이 0미만이라면, 다시 입력.
      - 스킬별 점유율 합산이 100초과하면, 다시 입력.
    - 리턴값
      - 마스터리 코어 리스트(리스트)
  
  - 현재 레벨 기준 스킬 %데미지 조정하는 함수.
    - 매개변수
      - 마스터리 코어 리스트(리스트)
    - 처리과정
      - 마스터리 코어별 딕셔너리 중 중복된 스킬이 있다면, 현재 레벨 기준 스킬 %데미지, 점유율을 조정함.
      - 조정된 현재 레벨 기준 스킬 %데미지, 점유율을 마스터리 코어 리스트(리스트)에 저장함.
      >&emsp;ex) 마스터리 코어2인 차지드라이브 변형 인스팅트 아츠 VI의 패시브 효과: 돌아오는 증오 VI 2%p 상승 효과와 마스터리 코어3인 돌아오는 증오 VI: 7%p 상승 효과가 서로에게 직접적으로 영향을 미침.<br>
      >&emsp;마스터리 코어2인 차지드라이브 변형 인스팅트 아츠 VI의 패시브 효과: 돌아오는 증오 VI의 현재 레벨 기준 스킬 %데미지 = 마스터리 코어3인 차지드라이브 변형 인스팅트 아츠 VI의 패시브 효과 + 강화스킬2인 돌아오는 증오 VI<br>
      >&emsp;마스터리 코어3인 돌아오는 증오 VI의 현재 레벨 기준 스킬 %데미지 = 마스터리 코어2인 차지드라이브 변형 인스팅트 아츠 VI의 패시브 효과: 돌아오는 증오 VI + 마스터리 코어3인 돌아오는 증오 VI
    - 처리사항
      - 두 딕셔너리 내에 중복된 키가 있는지, keys() + 교집합을 이용하여 중복된 키를 추출함.
    - 리턴값
      - 마스터리 코어 리스트(리스트)
  
  - 강화효율 산출하는 함수.
    - 매개변수
      - 마스터리 코어 리스트(리스트)
    - 설명
      - 마스터리 코어별/스킬별 최종데미지 상승율을 산출하는 과정.
    - 처리과정
      - 재화 시세, 마스터리 코어 1~30레벨 재화 소모량, 마스터리 코어 리스트(리스트)를 이용하여, 재화 효율, 스킬 최종데미지 상승율을 산출함. 
      - 1레벨 상승 시 최종데미지 상승율, 1레벨 상승 시 100억당 최종데미지 상승율, 5레벨 상승 시 평균 최종데미지 상승율, 5레벨 상승 시 100억당 평균 최종데미지 상승율을 산출함.
      - 모든 최종데미지 상승율은 마스터리 코어 리스트(리스트)에 저장함.
    - 처리사항
      - 재화 시세는 성능 향상을 위해 550만 대신 550을 사용함.
      - 재화 소모량 = 마스터리 코어 1~30레벨 재화 소모량[마스터리 코어[현재 레벨]]
      - 평균 재화 소모량은 (마스터리 코어 1~30레벨 재화 소모량에서 '현재 레벨' 부터 '현재 레벨 + 4'까지를 합산된 수치) / 5임.
      - 재화 효율은 성능 향상을 위해 100억 대신 100만을 사용함.
      - (평균)재화 효율 = 100만 / (재화 시세 * (평균)재화 소모량)
      - 스킬 데미지 상승율 = 1레벨 상승 시 %데미지 상승량(%p) / 현재 레벨 기준 %데미지
      - 평균 스킬 데미지 상승율은 (이 마스터리 코어를 5레벨 연속으로 강화했을 경우, 스킬 데미지 상승율이 합산된 수치) / 5 임.
      - (평균)최종데미지 상승율 = (평균)점유율 * (평균)스킬 데미지 상승율
      - 100억당 (평균)최종데미지 상승율 = (평균)재화 효율 * 점유율 * (평균)스킬 데미지 상승율
    - 리턴값
      - 마스터리 코어 리스트(리스트)
     
  - 강화 추천하는 함수.
    - 매개변수
      - 마스터리 코어 리스트(리스트) 
    - 처리과정
      - 마스터리 코어별로 1레벨 상승 시 100억당 최종데미지 상승율, 5레벨 상승 시 100억당 평균 최종데미지 상승율을 한 리스트에 담음.
      - 그 리스트에서 인덱스와 최댓값으로 가장 효율 좋은 마스터리 코어 번호 및 강화 횟수를 유추함.
    - 처리사항
      - 가장 효율 좋은 마스터리 코어 번호 = 최댓값 인덱스 // 2 + 1
      - 최댓값이 0이면, 0, 0을 리턴함.
        - 모든 스킬이 최대 레벨을 달성함.
      - 최댓값 인덱스 % 2가 0이면, 가장 효율 좋은 마스터리 코어 번호, 1을 리턴함.
        - 최댓값 인덱스는 0, 2, 4, 6이므로 1레벨 상승 시 100억당 최종데미지 상승율 관련 데이터가 존재함.
      - 아니라면, 가장 효율 좋은 마스터리 코어 번호, 5를 리턴함.
        - 최댓값 인덱스는 1, 3, 5, 7이므로 5레벨 상승 시 100억당 평균 최종데미지 상승율 관련 데이터가 존재함.
    - 리턴값
      - 가장 효율 좋은 마스터리 코어 번호, 강화 횟수
      
  - 결과를 출력하는 함수.
    - 매개변수
      - 마스터리 코어 번호, 강화 횟수.
    - 처리과정
      - 강화할 스킬이 있다면, 스킬 이름 및 추천 레벨 및 최종데미지 상승율을 출력함.
    - 처리사항
      - 강화 횟수가 0이라면, False를 리턴함.
        - 모든 스킬이 최대 레벨을 달성함.
      - 아니라면, True를 리턴함.
    - 리턴값
      - bool형
        
  - 점유율 조정하는 함수.
    - 매개변수
      - 마스터리 코어 리스트(리스트), 마스터리 코어 번호, 강화 횟수
    - 처리과정
      - 가장 효율 좋은 마스터리 코어 번호 및 강화 횟수를 활용하여 마스터리 코어 스킬의 현재 레벨, 점유율, 현재 레벨 기준 스킬 %데미지를 상승시킴.
      - 나머지 마스터리 코어의 점유율을 상승된 최종데미지에 비례하여 낮춤.
    - 처리사항
      - 가장 효율 좋은 마스터리 코어라면, 새로운 점유율을 '점유율 * (1 + 데미지 상승율)/ (1 + 점유율 * 데미지 상승율 / 100)'로 처리함.
        - 데미지 상승율 = 데미지 상승량(%p) / 현재 레벨 기준 스킬 %데미지
      - 나머지 마스터리 코어라면, 새로운 점유율을 '현재 점유율 / (1 + 합산된 점유율 상승량 / 100)'로 처리함.
        - 점유율 상승량 = 새로운 점유율 - 기존 점유율
    - 리턴값
      - 마스터리 코어 리스트(리스트)

  - 데미지 갱신하는 함수.
    - 매개변수
      - 마스터리 코어 리스트(리스트)
    - 처리과정
      - 서로 다른 마스터리 코어이면서 동일한 스킬의 현재 레벨 기준 %데미지가 다르다면, 높은 쪽의 점유율을 기준으로 현재 레벨 기준 스킬 %데미지와 점유율을 갱신함.
      >&emsp;ex) 마스터리 코어2인 차지드라이브 변형 인스팅트 아츠 VI의 패시브 효과: 돌아오는 증오 VI 2%p 상승 효과와 마스터리 코어3인 돌아오는 증오 VI: 7%p 상승 효과가 서로에게 직접적으로 영향을 미침.<br>
      >&emsp;마스터리 코어2인 차지드라이브 변형 인스팅트 아츠 VI의 패시브 효과: 돌아오는 증오 VI의 현재 레벨 기준 스킬 %데미지 = 마스터리 코어3인 차지드라이브 변형 인스팅트 아츠 VI의 패시브 효과 + 강화스킬2인 돌아오는 증오 VI <br>
      >&emsp;마스터리 코어3인 돌아오는 증오 VI의 현재 레벨 기준 스킬 %데미지 = 마스터리 코어2인 차지드라이브 변형 인스팅트 아츠 VI의 패시브 효과: 돌아오는 증오 VI + 마스터리 코어3인 돌아오는 증오 VI
    - 처리사항
      - 두 딕셔너리 내에 키가 중복인 키가 있는지 set()함수 + 교집합을 이용하여 확인함.
    - 리턴값
      - 마스터리 코어 리스트(리스트)

## 5. 시제품 결과
1. 프로젝트 이름: 아크 마스터리 코어 효율 시뮬레이션.
2. 개발 목표: 아크 직업의 마스터리 코어 효율을 정밀하게 분석하여 최적의 스킬 강화 방안을 도출합니다.
3. 주요 기능: 현재 스킬 레벨과 점유율을 바탕으로 강화 효율을 측정하여, 어떤 코어를 강화하는 것이 가장 효율적인지 추천합니다.
4. 전제조건: 기능 요구사항 문서를 참조 바랍니다. >> 하이퍼링크
5. 사용한 언어: Python.
6. 프로그램 구조: test_model_main.py은 메인 스크립트이며, 사용자가 입력한 데이터를 토대로 스킬 정보를 담고 있으며, test_model.py은 데이터 처리 로직을 모듈화한 스크립트 및 아크 직업 스킬 정보를 담고 있습니다.
7. 핵심 로직 및 공식: 구현 요구사항 문서를 참조 바랍니다. >> 하이퍼 링크
8. 시제품 사용 방법:<br>
   1.&nbsp;프로그램 실행을 위해 Python 환경이 필요합니다.<br>
   2.&nbsp;test_model.py와 test_model_main.py를 다운로드합니다.<br>
   3.&nbsp;test_model_main을 실행합니다.<br>
     - 테스트용 데이터 사용 시: test_model_main 스크립트 내에 아래와 같이 수정하면 데이터를 입력하지 않아도 개발자의 테스트용 데이터가 자동으로 입력됩니다.
     >&emsp;mastery_core_list = test_model.input_data(mastery_core_list)  ->  #mastery_core_list = test_model.input_data(mastery_core_list)<br>
     >&emsp;#mastery_core_list = test_model.test_data(mastery_core_list)  ->  mastery_core_list = test_model.test_data(mastery_core_list)<br><br>
     >&emsp;주의사항: test_data(mastery_core_list) 함수에는 데이터 검증 기능이 없습니다. 리스트화한 데이터에 비정상적인 데이터 종류 또는 값을 넣을 경우, 정확하지 않은 효율 측정 또는 오류를 일으킬 수 있으니 데이터를 변경하시는 경우 이 점을 주의해 주시기 바랍니다.
10. 시제품 이미지: 아래의 시제품 이미지는 사용자가 데이터를 입력하는 과정을 보여줍니다. 첫 사진의 파란색 영역을 보시면, 입력 형식이 다르거나 원하는 범위를 벗어난 값을 입력하면 재입력을 요구하도록 설정하여 프로그램의 안정성을 높였습니다. 또한, 모든 스킬의 강화 효율은 최대 레벨인 30레벨까지 출력되도록 구현했습니다. 그리고 그 아래의 빨간색 영역을 보시면, 일부 구간에서 5레벨 상승 시 효과가 좋다라는 것을 알 수 있습니다. 가장 마지막 사진의 초록색 영역을 보시면, 각 코어의 최대 레벨까지 효율을 측정한 것을 확인하실 수 있습니다.
    <img src="test_model_result_img/test_model_result_1.png" width="1000">
    <img src="test_model_result_img/test_model_result_2.PNG" width="1000">
    <img src="test_model_result_img/test_model_result_3.PNG" width="1000">
12. 제작 후기: 문서화 과정과 코드 최적화에 총 15일이 소요되었고, 그중 약 12일을 문서화에 할애했습니다. 저는 이 문서화 작업을 단순한 기록이 아닌 설명서라 생각하고, 다른 개발자가 프로젝트를 한눈에 이해할 수 있도록 만드는 데 집중했습니다.
