# 외부 데이터
base_skill_dmg = {
    "플레인 차지드라이브": 1839,
    "플레인 스펠": 373,
    "스칼렛 차지드라이브": 2118,
    "스칼렛 스펠": 1105,
    "거스트 차지드라이브": 2418,
    "거스트 스펠": 924,
    "어비스 차지드라이브": 3850,
    "어비스 스펠": 144,
    "지워지지 않는 상처": 2958,
    "채워지지 않는 굶주림": 3451,
    "걷잡을 수 없는 혼돈": 5316,
    "멈출 수 없는 충동": 2190,
    "멈출 수 없는 본능": 2778,
    "돌아오는 증오": 2898,
    "황홀한 구속": 36340,
    "끝없는 고통": 41400,
    "끝나지 않는 악몽": 2658,
    "끝나지 않는 흉몽": 2688,
    "다가오는 죽음": 906 + 133
}
mastery_core_1 = {
    "max_dmg": {
        "플레인 차지드라이브VI": 3615,
        "플레인 스펠VI": 1610,
        "스칼렛 차지드라이브VI": 4530,
        "스칼렛 스펠VI": 2375,
        "거스트 차지드라이브VI": 5250,
        "거스트 스펠VI": 1980,
        "어비스 차지드라이브VI": 7894,
        "어비스 스펠VI": 302,
        "깨어난 심연": 4380
    },
    "dmg_up": {
        "플레인 차지드라이브VI": 42,
        "플레인 스펠VI": 20,
        "스칼렛 차지드라이브VI": 54,
        "스칼렛 스펠VI": 30,
        "거스트 차지드라이브VI": 66,
        "거스트 스펠VI": 24,
        "어비스 차지드라이브VI": 102,
        "어비스 스펠VI": 4,
        "깨어난 심연": 48
    }
}
mastery_core_2 = {
    "max_dmg": {
        "지워지지 않는 상처VI": 8040,
        "채워지지 않는 굶주림VI": 9268,
        "걷잡을 수 없는 혼돈VI": 14220,
        "멈출 수 없는 충동": 2450,
        "멈출 수 없는 본능": 2940,
        "돌아오는 증오VI": 480
    },
    "dmg_up": {
        "지워지지 않는 상처VI": 102,
        "채워지지 않는 굶주림VI": 112,
        "걷잡을 수 없는 혼돈VI": 168,
        "멈출 수 없는 충동": 55,
        "멈출 수 없는 본능": 66,
        "돌아오는 증오VI": 16
    }
}
mastery_core_3 = {
    "max_dmg": {
        "돌아오는 증오VI": 8320,
        "황홀한 구속VI": 82200,
        "끝없는 고통VI": 66330
    },
    "dmg_up": {
        "돌아오는 증오VI": 96,
        "황홀한 구속VI": 920,
        "끝없는 고통VI": 630
    }
}
mastery_core_4 = {
    "max_dmg": {
        "잊혀지지 않는 악몽VI": 6685,
        "잊혀지지 않는 흉몽VI": 6797,
        "다가오는 죽음": 120
    },
    "dmg_up": {
        "잊혀지지 않는 악몽VI": 84,
        "잊혀지지 않는 흉몽VI": 84,
        "다가오는 죽음": 4
    }
}
mastery_core_cost = [50, 15, 18, 20, 23, 25, 28, 30, 33, 100,
                     40, 45, 50, 55, 60, 65, 70, 75, 80, 175,
                     85, 90, 95, 100, 105, 110, 115, 120, 125, 250]
mastery_core_list = [mastery_core_1, mastery_core_2, mastery_core_3, mastery_core_4]

def input_data(core):
    for i in range(4):
        while(True):
            cur_lvl = int(input("현재 마스터리 코어" + str(i + 1) + "의 현재 레벨을 입력하세요: "))

            if(type(cur_lvl) == int and 1 <= cur_lvl and cur_lvl <= 30):
                sum_rate = 0

                for j in mastery_core_list[i]["max_dmg"].keys():
                    # 현재 레벨 기준 마스터리 코어 %데미지 저장
                    core[i]["skill"][j]["cur_dmg"] = mastery_core_list[i]["max_dmg"][j] - mastery_core_list[i]["dmg_up"][j] * (30 - cur_lvl)
                    
                    # 기본 스킬 %데미지 합산
                    for k in base_skill_dmg.keys():
                        if(j == k):
                            core[i]["skill"][j]["cur_dmg"] += base_skill_dmg[k]
                    
                    if(cur_lvl == 30):
                        core[i]["skill"][j]["dmg_up"] = 0
                    else:
                        core[i]["skill"][j]["dmg_up"] = mastery_core_list[i]["dmg_up"][j]
                    
                    rate = float(input(j + "의 점유율을 입력하세요: "))
                    core[i]["skill"][j]["rate"] = rate
                    sum_rate = rate
                break
            else:
                print("입력된 정보(현재 레벨)가 잘못되었습니다.")
            
            if(sum_rate > 100):
                print("입력된 정보(점유율)가 잘못되었습니다.")
    
    return core
def test_data(core):
    cur_lvl = [19, 9, 9, 9]
    rate = [[3.84, 1.63, 0.54, 0.27, 0.89, 0.32, 0.89, 0.35, 11.51], [1.61, 1.93, 1.99, 0.61, 1.51, 12.14], [12.14, 2.32, 2.0], [0.96, 8.42, 27.1]]

    for i in range(4):
        temp = 0

        for j in mastery_core_list[i]["max_dmg"].keys():
            core[i]["skill"][j]["cur_dmg"] = mastery_core_list[i]["max_dmg"][j] - mastery_core_list[i]["dmg_up"][j] * (30 - cur_lvl[i])
                    
            for k in base_skill_dmg.keys():
                if(j == k):
                    core[i]["skill"][j]["cur_dmg"] += base_skill_dmg[k]
            
            core[i]["skill"][j]["rate"] = rate[i][temp]
            temp += 1
    return core

def modify_dmg(core):
    for i in range(1, len(core)):
        for j in range(i, len(core)):
            for value1 in core[i]["skill"]:
                for value2 in core[j]["skill"]:
                    if(value1 == value2):
                        keys1 = set(core[i]["skill"])
                        keys2 = set(core[j]["skill"])
                        common_keys = keys1 & keys2
                        for k in common_keys:
                          temp_dmg = core[i]["skill"][k]["cur_dmg"] + core[j]["skill"][k]["cur_dmg"]
                          core[i]["skill"][k]["cur_dmg"] = temp_dmg
                          core[j]["skill"][k]["cur_dmg"] = temp_dmg
    return core


"""
현재 레벨 기준 스킬 %데미지 조정하는 함수.

매개변수
마스터리 코어 리스트(리스트)
처리과정
마스터리 코어별 현재 레벨에 따라 현재 레벨 기준 스킬 %데미지를 마스터리 코어 리스트(리스트)에 저장함.
서로 다른 마스터리 코어가 같은 스킬 %데미지를 중복으로 상승시킬 경우, 해당하는 마스터리 코어들의 현재 레벨 기준 스킬 %데미지를 합산하여 각각 현재 레벨 기준 스킬 %데미지로 조정함.
아니라면, 아무것도 실행하지 않음.
ex) 마스터리 코어2인 차지드라이브 변형 인스팅트 아츠 VI의 패시브 효과: 돌아오는 증오 VI 2%p 상승 효과와 마스터리 코어3인 돌아오는 증오 VI: 7%p 상승 효과가 서로에게 직접적으로 영향을 미침.
마스터리 코어2인 차지드라이브 변형 인스팅트 아츠 VI의 패시브 효과: 돌아오는 증오 VI의 현재 레벨 기준 스킬 %데미지 = 마스터리 코어3인 차지드라이브 변형 인스팅트 아츠 VI의 패시브 효과 + 강화스킬2인 돌아오는 증오 VI
마스터리 코어3인 돌아오는 증오 VI의 현재 레벨 기준 스킬 %데미지 = 마스터리 코어2인 차지드라이브 변형 인스팅트 아츠 VI의 패시브 효과: 돌아오는 증오 VI + 마스터리 코어3인 돌아오는 증오 VI

처리사항
임시 변수에 합산된 수치를 넣고, 해당하는 마스터리 코어들의 현재 레벨 기준 스킬 %데미지가 임시 변수와 같다고 처리해야함.
한 변수를 다른 변수에 더하는 방식(변수1 += 변수2)으로 처리하면 각각의 스킬 %데미지가 다르게 됨.
두 딕셔너리 내에 키가 중복인 키가 있는지 set()함수 + 교집합을 이용하여 확인함.
리턴값
마스터리 코어 리스트(리스트)

  - 강화효율을 산출하는 함수.
    - 매개변수 = 재화효율, 점유율, 스킬 데미지 상승율
    - 최종데미지 상승율 = 점유율 * 스킬 데미지 상승율
    - 100억당 최종데미지 상승율 = 재화 효율 * 점유율 * 스킬 데미지 상승율
    - 리턴값 = 최종데미지 상승율, 100억당 최종데미지 상승율
  
  - 1레벨 상승 시 강화효율을 산출하는 함수.
    - 매개변수 = 마스터리 코어(딕셔너리)
    - 재화 시세 = 550
      - 구현에서는 성능 향상을 위해 550만 대신 550으로 사용함.
    - 재화 소모량 = 마스터리 코어 1~30레벨 재화 소모량[마스터리 코어[현재 레벨]]
    - 재화 효율 = 100만 / (재화 시세 * 재화 소모량)
    - 1레벨 상승 시 최종데미지 상승율 합산 = 0
    - 1레벨 상승 시 100억당 최종데미지 상승율 합산 = 0
    - for i in 마스터리 코어[스킬].items():
      - 스킬 데미지 상승율 = 마스터리 코어[스킬][i][1레벨 상승 시 %데미지 상승량(%p)] / 마스터리 코어[스킬][i][현재 레벨 기준 %데미지]
      - 1레벨 상승 시 최종데미지 상승율, 1레벨 상승 시 100억당 최종데미지 상승율 = 강화효율을 산출하는 함수(재화 효율, 마스터리 코어[스킬][점유율], 스킬 데미지 상승율)
      - 1레벨 상승 시 최종데미지 상승율 합산 += 1레벨 상승 시 최종데미지 상승율
      - 1레벨 상승 시 100억당 최종데미지 상승율 합산 += 1레벨 상승 시 100억당 최종데미지 상승율
    - 리턴값 = 1레벨 상승 시 최종데미지 상승율 합산, 1레벨 상승 시 100억당 최종데미지 상승율 합산
  
  - 5레벨 상승 시 평균 강화효율 체크하는 함수.
    - 매개변수 = 마스터리 코어(딕셔너리)
    - 재화 시세 = 550
      - 구현에서는 성능 향상을 위해 550만 대신 550으로 사용함.
    - 평균 재화 소모량 = sum(마스터리 코어 1~30레벨 재화 소모량[마스터리 코어[현재 레벨] : 마스터리 코어[현재 레벨] + 5]) / 5
      - 평균 재화 소모량은 (마스터리 코어 1~30레벨 재화 소모량에서 '현재 레벨' 부터 '현재 레벨 + 4'까지를 합산된 수치) / 5임.
    - 평균 재화 효율 = 100만 / (재화 시세 * 평균 재화 소모량)
    - 5레벨 상승 시 평균 최종데미지 상승율 합산 = 0
    - 5레벨 상승 시 100억당 평균 최종데미지 상승율 합산 = 0
    - for i in 마스터리 코어[스킬].items():
      - tempA = 마스터리 코어[스킬][i][1레벨 상승 시 %데미지 상승량(%p)]
      - tempB = 마스터리 코어[스킬][i][현재 기준 레벨 %데미지]
      - 평균 스킬 데미지 상승율 = {tempA / tempB + tempA / (tempB + tempA) + tempA / (tempB + 2 * tempA) + tempA / (tempB + 3 * tempA) + tempA / (tempB + 4 * tmepA)} / 5
        - 평균 스킬 데미지 상승량은 (이 마스터리 코어를 5레벨 연속으로 강화했을 경우, 스킬 데미지 상승율이 합산된 수치) / 5 임.
      - 5레벨 상승 시 평균 최종데미지 상승율, 5레벨 상승 시 100억당 평균 최종데미지 상승율 = 강화효율을 산출하는 함수(평균 재화 효율, 마스터리 코어[스킬][점유율], 평균 스킬 데미지 상승율)
      - 5레벨 상승 시 평균 최종데미지 상승율 합산 += 5레벨 상승 시 평균 최종데미지 상승율
      - 5레벨 상승 시 100억당 평균 최종데미지 상승율 합산 += 5레벨 상승 시 100억당 평균 최종데미지 상승율
    - 리턴값 = 5레벨 상승 시 평균 최종데미지 상승율 합산, 5레벨 상승 시 100억당 평균 최종데미지 상승율 합산
  
  - 마스터리 코어별로 강화효율 산출하는 함수.
    - 매개변수 = 마스터리 코어 리스트(리스트)
    - for i in range(4):
      - 마스터리 코어 리스트[i][데미지 상승율][1레벨 상승 시 최종데미지 상승율], 마스터리 코어 리스트[i][데미지 상승율][1레벨 상승 시 100억당 최종데미지 상승율] = 1레벨 상승 시 강화효율을 산출하는 함수(마스터리 코어[i])
      - 마스터리 코어 리스트[i]'[데미지 상승율][5레벨 상승 시 평균 최종데미지 상승율], 마스터리 코어 리스트[i][데미지 상승율][5레벨 상승 시 100억당 평균 최종데미지 상승율] = 5레벨 상승 시 평균 강화효율 체크하는 함수(마스터리 코어 리스트[i])
    - 리턴값 = 마스터리 코어 리스트(리스트)

  - 강화 추천하는 함수.
    - 매개변수 = 마스터리 코어 리스트(리스트)
    - 100억당 최종데미지 상승율 리스트 = []
    - for i in range(4):
        - 100억당 최종데미지 상승율 리스트.append(마스터리 코어[i][데미지 상승율][1레벨 상승 시 100억당 최종데미지 상승율])
        - 100억당 최종데미지 상승율 리스트.append(마스터리 코어[i][데미지 상승율][5레벨 상승 시 100억당 평균 최종데미지 상승율])
    - 최댓값 = 0
    - for 번호, 100억당 최종데미지 상승율 in enumerate(100억당 최종데미지 상승율 리스트):
      - if 100억당 최종데미지 상승율 > 최댓값:
        - 최댓값 = 100억당 최종데미지 상승율
        - 최댓값 번호 = 번호
    - 가장 좋은 강화효율인 마스터리 코어 번호 = 최댓값 번호 // 2 + 1
    - if 최댓값 = 0:
        - 최댓값이 0인 경우는 모든 스킬이 최대 레벨을 달성했다는 것을 의미함. 
      - 리턴값 = 0, 0 
    - if 최댓값 번호 % 2 == 0:
        - 최댓값 번호가 0, 2, 4, 6인 경우, 1레벨 상승 시 100억당 최종데미지 상승율 관련 데이터가 존재함.
      - 강화 횟수 = 1
    - else:
        - 최댓값 번호가 1, 3, 5, 7인 경우, 5레벨 상승 시 100억당 평균 최종데미지 상승율 관련 데이터가 존재함.
      - 강화 횟수 = 5
   - 리턴값 = 가장 좋은 강화효율인 마스터리 코어 번호, 강화 횟수
  
  - 결과를 출력하는 함수.
    - 매개변수 = 마스터리 코어 번호, 강화 횟수.
    - if 마스터리 코어 번호 == 0:
        - 리턴값 = false
    - else:
        - print(f'마스터리 코어{마스터리 코어 번호}', end = " ")
        - print(마스터리 코어 리스트[마스터리 코어 번호 - 1][현재 레벨] + 강화 횟수)
        - if(강화 횟수 == 1):
          - print("1레벨 상승 시 최종데미지 상승율", end = " ")
          - print(마스터리 코어 리스트[마스터리 코어 번호 - 1][데미지 상승율][1레벨 상승 시 최종데미지 상승율])
          - print("1레벨 상승 시 100억당 최종데미지 상승율", end = " ")
          - print(마스터리 코어 리스트[마스터리 코어 번호 - 1][데미지 상승율][1레벨 상승 시 100억당 최종데미지 상승율])
        - else:
          - print("5레벨 상승 시 평균 최종데미지 상승율", end = " ")
          - print(마스터리 코어 리스트[마스터리 코어 번호 - 1][데미지 상승율][5레벨 상승 시 평균 최종데미지 상승율])
          - print("5레벨 상승 시 100억당 평균 최종데미지 상승율", end = " ")
          - print(마스터리 코어 리스트[마스터리 코어 번호 - 1][데미지 상승율][5레벨 상승 시 100억당 평균 최종데미지 상승율])
    - 리턴값 = true

- 점유율 조정.
그 이유는 캐릭터마다 스킬이 효율에 영향이 가는 부분이 존재하기 때문임.
딜 상승량 = f'마스터리 코어{i}' [최종데미지] 라는 변수 하나 생성.

마스터리 코어별
  점유율 조정
  퍼뎀 조정

문제는 뭐냐.
마스터리 코어 중 중복되는 값이 있을 거란 말이지. 퍼뎀을 전체 처리를 하는게 아니니까.

마스터리 코어별로 점유율에 따른 함수를 만드는게 정배임.

어떻게 하냐. 
def 마스터리 코어1 점유율
매개변수는 마스터리 코어1 딕셔너리, 딜 상승량, 인덱스
case문으로 인덱스가
1이라면,
   딕셔너리 내에 있는 스킬 개수만큼 시행.
       스킬배율 = (현재스킬 퍼뎀+퍼뎀 상승율(%p)) / 현재스킬퍼뎀
       딕셔너리 내에 있는
       점유율에 있는 수치를 점유율 * (스킬 배율-1) / 1 + ((스킬 배율-1) / 점유율)로 변경.
       현재 스킬 퍼뎀 조정.
      다른 마코 점유율 조정

2라면,

3이라면,

4이라면,


조정.

30레벨까지 시행.
30레벨 이상일 때는 측정하면 안되니 현재 퍼뎀과 30레벨 이상 퍼뎀이 같다면, 스킬 퍼뎀 상승량은 0으로 변경


만약에 모든 딜 상승량이 0이라면, 끝나게 설정.








  1. 변수에 재화 시세를 550을 저장함.
      - 구현에서는 성능 향상을 위해 550만 대신 550으로 사용함.
  2. 리스트에 마스터리 코어 1~30레벨 재화 소모량을 저장함.
  3. 마스터리코어별 레벨 입력받기(그림 참조)
  4. 마스터리코어별 스킬 순서대로 점유율 입력받기(그림 참조)
  5. 마스터리코어별 강화효율 측정
      -  1. 변수에 재화 시세를 550을 저장함.
      - 구현에서는 성능 향상을 위해 550만 대신 550으로 사용함.
     -  2. 리스트에 마스터리 코어 1~30레벨 재화 소모량을 저장함.
      - 재화 효율은 100억 메소 기준으로 재화시세 * 소모 재화량임.
  7. 마스터리 코어별 강화효율 확인(누가 제일 높은지)
  8. 마스터리 코어 추천 및 강화.
  9. 모든 마스터리 코어 점유율 변경.
  10. 5~8과정을 모든 마스터리 코어 30레벨 될 때 까지 시행.

- 강화효율 측정하는 모듈.
 구현에서는 성능 향상을 위해 100억 대신 100만으로 사용함.

> 로직 그림
 마스터리 코어별 강화효율은 '현재 레벨 +1', '(현재레벨 + 1 : 현재레벨 + 5) / 5'  2가지를 기준으로 산출함.

 스킬별 배율은 다음 레벨 스킬 %데미지 / 현재 레벨 스킬 %데미지로 계산함.
 강화 시 최종데미지 상승량은 마스터리 코어에 관련된 스킬별 '점유율 * 스킬 배율'의 합산임.
 강화 시 100억당 최종데미지 상승량은 마스터리 코어에 관련된 스킬별 '점유율 * 스킬 배율 * 재화효율'의 합산임.
 이 2가지를 함수에서 리턴하여 마스터리 코어 순서에 따라 순서대로 강화 시 최종데미지 상승량, 100억당 최종데미지 상승량을 변경함.
 리스트에는 2가지 정보가 저장됨.

 강화시 최종데미지 상승량에는 순서대로현재 레벨 +1 일 경우와 '(현재레벨 + 1 : 현재레벨 + 5) / 5' 일 경우의 강화시 최종데미지 상승량이 마스터리 코어1, 2, 3, 4 순으로 저장되어 있음.
 강화 시 100억당 최종데미지 상승량에도 순서대로현재 레벨 +1 일 경우와 '(현재레벨 + 1 : 현재레벨 + 5) / 5' 일 경우의 강화시 최종데미지 상승량이 마스터리 코어1, 2, 3, 4 순으로 저장되어 있음.

 모든 강화효율 값 중 높은 수치를 기준으로 스킬을 강화함.

 스킬 강화 후에 모든 스킬도 점유율을 재조정함.

- 마스터리 코어별 점유율 변경해주는 로직.

- 점유율 재조정하는 로직.

 강화가 된 마스터리코어의 스킬의 경우,
 모든 마스터리 코어 점유율을 재조정하는 방법은 스킬 점유율 / (100 - 강화된 현시점 최종데미지 상승량 수치)임.
 위 과정을 모든 마스터리 코어가 30레벨될 때까지 반복함.

- 특수로직1.
- 마스터리 코어2, 3에 대해서 특수로직1 발생.
- 마스터리 코어2(상처VI/굶주림VI/혼돈VI)
패시브: 멈출 수 없는 충동/본능 %p, 돌아오는 증오 %p, 돌아오는 증오VI %p 상승.
- 마스터리 코어3(증오VI/고통VI/구속VI)
- 마스터리 코어3을 1레벨 이상인지 확인.
- 위 조건이 맞다면, 마스터리 코어2의 패시브인 멈출 수 없는 충동/본능 %p, 돌아오는 증오VI %p 적용, 특수로직2 발생.
- 위 조건이 아니라면, 마스터리 코어2의 패시브인 멈출 수 없는 충동/본능 %p, 돌아오는 증오 %p 적용.

- 특수로직2.
- 마스터리 코어2, 3에 대해서 특수로직2 발생.
- 마스터리 코어2(상처VI/굶주림VI/혼돈VI)
패시브: 멈출 수 없는 충동/본능 %p, 돌아오는 증오 %p, 돌아오는 증오VI %p 상승.
- 마스터리 코어3(증오VI/고통VI/구속VI)
- 마스터리 코어2 강화 효율 계산 시, 마스터리 코어3의 증오VI의 레벨당 퍼센트 데미지를 가지고 패시브인 돌아오는 증오VI %p 효과를 계산함.
- 마스터리 코어3 강화 효율 계산 시, 마스터리 코어2의 패시브인 돌아오는 증오VI %p 상승을 포함하여 계산함.



- 마스터리 코어별 강화 시 최종데미지 상승량 측정(+1렙, +5렙까지의 평균값).
 입력값은 스킬별 점유율, 스킬별 공격횟수인 딕셔너리, 스킬레벨 중 

- 마스터리 코어별 모든 효율 비교.
- 스킬 강화 후 스킬 점유율 조정.

1. 시제품에서 제작해야할 요소.
함수1. 강화 시 데미지 상승량 측정(+1렙, +5렙까지의 평균값).
함수2. 두 스킬의 효율 비교.
함수3. 스킬 하나를 강화 후 점유율 변경.



스킬별로 상승량을 책정해 점유율을 변동하는 로직.
-> 초기에 스킬별 점유율을 기준 스킬의 점유율과 비교해서 환산하는 로직.
"""